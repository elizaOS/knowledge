{
  "interval": {
    "intervalStart": "2026-01-12T00:00:00.000Z",
    "intervalEnd": "2026-01-13T00:00:00.000Z",
    "intervalType": "day"
  },
  "repository": "elizaos/eliza",
  "overview": "From 2026-01-12 to 2026-01-13, elizaos/eliza had 1 new PRs (2 merged), 0 new issues, and 7 active contributors.",
  "topIssues": [
    {
      "id": "I_kwDOMT5cIs7gwUMG",
      "title": "Unslop Apps",
      "author": "borisudovicic",
      "number": 6299,
      "repository": "elizaos/eliza",
      "body": "",
      "createdAt": "2025-12-30T17:02:05Z",
      "closedAt": "2026-01-12T16:38:43Z",
      "state": "CLOSED",
      "commentCount": 0
    }
  ],
  "topPRs": [
    {
      "id": "PR_kwDOMT5cIs68hB9v",
      "title": "feat: add plugin-blockrun for x402 micropayments",
      "author": "1bcMax",
      "number": 6355,
      "body": "## Summary\n\nAdd **BlockRun plugin** enabling ElizaOS agents to make pay-per-request AI calls using [x402 micropayments](https://x402.org) on Base chain.\n\n- **BLOCKRUN_CHAT** action: Pay-per-request access to OpenAI, Anthropic, Google, and more\n- **BLOCKRUN_WALLET** provider: Wallet address and USDC balance on Base\n- Automatic x402 payment handling via EIP-712 signatures\n- No API keys required - just a wallet with USDC\n\n## How it works\n\n1. Agent makes an AI request via `BLOCKRUN_CHAT` action\n2. BlockRun gateway returns `402 Payment Required` with price\n3. Plugin signs USDC payment (EIP-712 TransferWithAuthorization)\n4. Request retries with payment signature\n5. AI response returned to agent\n\nTypical cost: **$0.001-0.01 per request**\n\n## Configuration\n\n```env\nBASE_CHAIN_WALLET_KEY=0x...  # Private key with USDC on Base\n```\n\n## Usage\n\n```typescript\nimport { blockrunPlugin } from '@elizaos/plugin-blockrun';\n\nconst agent = new Agent({\n  plugins: [blockrunPlugin],\n});\n```\n\n## Test plan\n\n- [x] Unit tests for plugin exports\n- [x] Wallet provider returns address and balance\n- [x] Action validates wallet configuration\n- [x] E2E test with real x402 payments (3 successful API calls)\n\n## Links\n\n- [BlockRun](https://blockrun.ai) - Pay-per-request AI gateway\n- [x402 Protocol](https://x402.org) - HTTP 402 micropayment standard\n- [@blockrun/llm SDK](https://github.com/BlockRunAI/blockrun-llm-ts)\n\n---\n\ncc @w1kke - discussed integration on Twitter\n\n<!-- greptile_comment -->\n\n<h2>Greptile Overview</h2>\n\n### Greptile Summary\n\nThis PR adds a BlockRun plugin that enables ElizaOS agents to make pay-per-request AI calls using the x402 micropayment protocol on Base chain. The plugin provides a `BLOCKRUN_CHAT` action for making AI API calls and a `BLOCKRUN_WALLET` provider for wallet context.\n\n## What Changed\n\nThe PR introduces a complete plugin package (`@elizaos/plugin-blockrun`) with:\n- **Action**: `BLOCKRUN_CHAT` - handles AI requests with automatic x402 payment flow\n- **Provider**: `BLOCKRUN_WALLET` - supplies wallet address and USDC balance on Base\n- **Dependencies**: Uses `@blockrun/llm` SDK for payment handling and `viem` for blockchain interactions\n- **Tests**: Comprehensive unit and E2E tests validating the payment flow\n\n## Architecture\n\nThe plugin follows ElizaOS patterns with proper action/provider structure:\n1. User sends message to agent\n2. Action validates wallet configuration\n3. LLMClient makes request to BlockRun gateway\n4. Gateway returns 402 Payment Required with price\n5. Client signs USDC payment via EIP-712\n6. Request retries with payment signature\n7. AI response returned to agent\n\n## Key Implementation Details\n\n- **Client Caching**: LLMClient instances are cached per agent ID to avoid recreating connections\n- **Wallet Configuration**: Supports `BASE_CHAIN_WALLET_KEY` and `BLOCKRUN_WALLET_KEY` settings\n- **Error Handling**: Comprehensive try-catch blocks with structured logging\n- **Model Support**: OpenAI, Anthropic, Google models via unified interface\n\n## Critical Issues Found\n\n1. **Hardcoded Path** (test-e2e.ts:9): Import uses absolute local path that breaks for other developers\n2. **Missing LICENSE**: Package.json references LICENSE file not included in PR\n3. **Git Dependency**: Uses git URL instead of published npm package for @blockrun/llm\n\n## Code Quality\n\nThe code is well-structured with:\n- Proper TypeScript typing throughout\n- Good error handling and logging\n- Clear documentation and examples\n- Comprehensive test coverage including real payment flows\n- Follows ElizaOS plugin architecture patterns\n\n### Confidence Score: 3/5\n\n- This PR has good functionality but contains a critical bug that breaks builds for other developers\n- Score reflects one critical syntax error (hardcoded local path) that will cause immediate build failures, plus two medium-priority issues (missing LICENSE file and git dependency). The core implementation is solid with proper error handling, validation, and comprehensive tests. Once the hardcoded path is fixed, this would be a 4/5.\n- test-e2e.ts requires immediate fix for hardcoded path. package.json needs LICENSE file added and consideration of publishing @blockrun/llm to npm.\n\n<h3>Important Files Changed</h3>\n\n\n\nFile Analysis\n\n\n\n| Filename | Score | Overview |\n|----------|-------|----------|\n| packages/plugin-blockrun/test-e2e.ts | 1/5 | Contains hardcoded local path that breaks for other developers - critical bug on line 9 |\n| packages/plugin-blockrun/package.json | 3/5 | Missing LICENSE file and uses git dependency instead of npm package version |\n| packages/plugin-blockrun/src/actions/chat.ts | 4/5 | Well-structured action with proper error handling and validation |\n| packages/plugin-blockrun/src/providers/wallet.ts | 4/5 | Properly implements wallet provider with balance checking and error handling |\n| packages/plugin-blockrun/src/__tests__/e2e.test.ts | 4/5 | Comprehensive test coverage with proper mocking and E2E tests |\n\n</details>\n\n\n\n<h3>Sequence Diagram</h3>\n\n```mermaid\nsequenceDiagram\n    participant Agent as ElizaOS Agent\n    participant Action as BLOCKRUN_CHAT Action\n    participant Client as LLMClient (@blockrun/llm)\n    participant Gateway as BlockRun Gateway\n    participant Base as Base Chain\n\n    Agent->>Action: User message (prompt)\n    Action->>Action: Validate wallet key configured\n    Action->>Client: getClient(runtime)\n    Note over Client: Cache client by agentId\n    \n    Action->>Client: chat(model, prompt, options)\n    Client->>Gateway: HTTP Request (AI query)\n    Gateway-->>Client: 402 Payment Required (price)\n    \n    Client->>Client: Sign USDC payment (EIP-712)\n    Note over Client: TransferWithAuthorization\n    \n    Client->>Gateway: Retry with payment signature\n    Gateway->>Base: Verify signature & transfer USDC\n    Base-->>Gateway: Payment confirmed\n    \n    Gateway->>Gateway: Process AI request\n    Gateway-->>Client: AI response\n    Client-->>Action: Response text\n    \n    Action->>Agent: ActionResult with response\n    Note over Agent: Display AI response to user\n```\n\n<!-- greptile_other_comments_section -->\n\n<sub>(2/5) Greptile learns from your feedback when you react with thumbs up/down!</sub>\n\n<!-- /greptile_comment -->",
      "repository": "elizaos/eliza",
      "createdAt": "2026-01-11T03:27:18Z",
      "mergedAt": null,
      "additions": 1000,
      "deletions": 0
    },
    {
      "id": "PR_kwDOMT5cIs68Atkl",
      "title": "fix: optimize runtime initialization with parallelization and atomic upserts",
      "author": "standujar",
      "number": 6342,
      "body": "## Summary\r\n\r\nOptimize `runtime.initialize()` performance through atomic upserts and parallelization of independent operations.\r\n\r\n**Results:** Cold start -30%, Warm start -40%\r\n\r\n## Problem\r\n\r\nThe current initialization flow has several inefficiencies:\r\n1. Sequential check-then-insert patterns with race condition potential\r\n2. Multiple round-trips to DB for existence checks before inserts\r\n3. Sequential operations that could run in parallel\r\n\r\n## Solution\r\n\r\n### 1. Atomic Upserts (plugin-sql/base.ts)\r\n\r\nReplace check-then-insert with `INSERT ... ON CONFLICT DO NOTHING`:\r\n\r\n```typescript\r\n// Before: Two queries + race condition\r\nconst existing = await this.getWorld(world.id);\r\nif (existing) throw new Error('World already exists');\r\nawait this.db.insert(worldTable).values(world);\r\n\r\n// After: Single atomic query\r\nawait this.db.insert(worldTable).values(world).onConflictDoNothing();\r\n```\r\n\r\nApplied to:\r\n- `createWorld()` - returns silently if world exists\r\n- `createEntities()` - skips existing entities in batch\r\n\r\n### 2. Parallel Initialization (core/runtime.ts)\r\n\r\n```typescript\r\n// Before: Sequential\r\nawait this.ensureWorldExists();\r\nawait this.runMigrations();\r\nconst entity = await this.getEntityById(entityId);\r\nconst room = await this.getRoomById(roomId);\r\n\r\n// After: Parallel where possible\r\nawait Promise.all([\r\n  this.ensureWorldExists(),\r\n  options?.skipMigrations ? Promise.resolve() : this.runMigrations()\r\n]);\r\n\r\nconst [entity, room] = await Promise.all([\r\n  this.getEntityById(entityId),\r\n  this.getRoomById(roomId)\r\n]);\r\n```\r\n\r\n### 3. Idempotent Ensure Methods\r\n\r\n- `ensureWorldExists()` - Always calls `createWorld()`, DB handles duplicates\r\n- `ensureRoomExists()` - Always calls `createRoom()`, DB handles duplicates\r\n- `ensureEntity()` - New method using upsert pattern\r\n\r\n### 4. Code Cleanup (server/message.ts)\r\n\r\nRemoved defensive try/catch blocks that were handling race conditions no longer possible with atomic upserts.\r\n\r\n## Files Changed\r\n\r\n| File | Changes |\r\n|------|---------|\r\n| `packages/plugin-sql/src/base.ts` | Added `onConflictDoNothing()` to createWorld, createEntities |\r\n| `packages/core/src/runtime.ts` | Parallel init, extracted `mergeAgentSettings()`, added `ensureEntity()` |\r\n| `packages/server/src/services/message.ts` | Removed unnecessary try/catch blocks |\r\n| `packages/*/src/__tests__/**` | Updated tests for idempotent behavior |\r\n\r\n## Benchmark Details\r\n\r\n```\r\nEnvironment: PGLite (in-memory), 20 iterations each\r\n\r\n=== COLD START (fresh DB each time) ===\r\nDelta:  -30%\r\n\r\n=== WARM START (agent already exists) ===\r\nDelta:  -40%\r\n```\r\n\r\n## Test Plan\r\n\r\n- [x] `bun test packages/core/src/__tests__/runtime.test.ts` - 47 pass\r\n- [x] `bun test packages/plugin-sql/src/__tests__/unit/` - 147 pass\r\n- [x] `bun test packages/plugin-sql/src/__tests__/integration/` - All suites pass\r\n- [x] Idempotent behavior verified: calling ensure methods multiple times succeeds\n\n<!-- greptile_comment -->\n\n<h3>Greptile Summary</h3>\n\n\nThis PR successfully optimizes runtime initialization by replacing check-then-insert patterns with atomic upserts and parallelizing independent operations, achieving the claimed 30% cold start and 40% warm start improvements.\n\n## Key Changes\n\n- **Atomic Upserts**: Added `.onConflictDoNothing()` to `createWorld()` and `createEntities()` in `plugin-sql/base.ts`, eliminating race conditions and reducing round-trips\n- **Parallelization**: Refactored `runtime.initialize()` to execute world creation and migrations in parallel, then entity/room/participant lookups in parallel\n- **Code Cleanup**: Removed defensive try/catch blocks in `message.ts` that were handling race conditions no longer possible with atomic operations\n- **Refactoring**: Extracted `mergeAgentSettings()` method and added `ensureEntity()` helper for cleaner code organization\n\n## Issues Found\n\n- **`ensureEntity()` implementation** (runtime.ts:2668): Returns the input entity object rather than fetching the actual persisted entity from the database, which differs from typical ensure patterns and could cause issues if callers expect database-populated fields\n\n## Performance Impact\n\nThe changes are well-architected for performance:\n- Atomic operations reduce DB round-trips from 2+ queries per entity/world to 1\n- Parallel execution of independent operations (world creation + migrations, then entity + room + participants) maximizes throughput\n- Idempotent operations enable safe retries without application-level locking\n\nTests properly verify idempotent behavior and preserve-first-write semantics.\n\n<h3>Confidence Score: 4/5</h3>\n\n\n- This PR is safe to merge with one logic issue requiring clarification\n- The atomic upsert pattern and parallelization are well-implemented with proper tests. Score reduced by 1 point due to the `ensureEntity()` implementation question that needs clarification - it may be intentional but differs from expected ensure pattern behavior.\n- Pay close attention to `packages/core/src/runtime.ts` - verify the `ensureEntity()` return behavior is intentional\n\n<h3>Important Files Changed</h3>\n\n\n\n\n| Filename | Overview |\n|----------|----------|\n| packages/core/src/runtime.ts | Refactored initialization to use `Promise.all()` for parallel execution (world creation and migrations), extracted `mergeAgentSettings()` method, and added `ensureEntity()` helper. One potential issue with `ensureEntity()` always returning the input entity. |\n| packages/plugin-sql/src/base.ts | Added `onConflictDoNothing()` to `createWorld()` and `createEntities()` for atomic upserts, eliminating race conditions. Clean implementation with proper idempotency. |\n| packages/server/src/services/message.ts | Removed defensive try/catch blocks around `ensureWorldExists()` and `ensureRoomExists()` as atomic upserts now handle duplicates at DB level. |\n\n</details>\n\n\n\n<h3>Sequence Diagram</h3>\n\n```mermaid\nsequenceDiagram\n    participant Runtime as AgentRuntime\n    participant Adapter as DatabaseAdapter\n    participant DB as Database\n\n    Note over Runtime,DB: Cold Start Initialization\n\n    Runtime->>Adapter: ensureAgentExists()\n    Adapter->>DB: INSERT agent ON CONFLICT DO NOTHING\n    DB-->>Adapter: Success\n    Adapter-->>Runtime: Agent entity\n\n    Runtime->>Runtime: mergeAgentSettings()\n    \n    par Parallel Initialization\n        Runtime->>Adapter: ensureWorldExists()\n        Adapter->>DB: INSERT world ON CONFLICT DO NOTHING\n        DB-->>Adapter: Success (idempotent)\n        Adapter-->>Runtime: World created/exists\n    and\n        Runtime->>Adapter: runPluginMigrations()\n        Adapter->>DB: Run migrations\n        DB-->>Adapter: Migrations complete\n        Adapter-->>Runtime: Done\n    end\n\n    par Parallel Entity/Room Setup\n        Runtime->>Adapter: ensureEntity()\n        Adapter->>DB: INSERT entity ON CONFLICT DO NOTHING\n        DB-->>Adapter: Success (idempotent)\n        Adapter-->>Runtime: Entity created/exists\n    and\n        Runtime->>Adapter: getRoom()\n        Adapter->>DB: SELECT room\n        DB-->>Adapter: Room data or null\n        Adapter-->>Runtime: Room data\n    and\n        Runtime->>Adapter: getParticipantsForRoom()\n        Adapter->>DB: SELECT participants\n        DB-->>Adapter: Participant list\n        Adapter-->>Runtime: Participants\n    end\n\n    alt Room doesn't exist\n        Runtime->>Adapter: createRoom()\n        Adapter->>DB: INSERT room\n        DB-->>Adapter: Success\n        Adapter-->>Runtime: Room created\n    end\n\n    alt Agent not participant\n        Runtime->>Adapter: addParticipant()\n        Adapter->>DB: INSERT participant\n        DB-->>Adapter: Success\n        Adapter-->>Runtime: Participant added\n    end\n\n    Note over Runtime,DB: Initialization Complete (-30% cold, -40% warm)\n```\n\n<!-- greptile_other_comments_section -->\n\n<!-- /greptile_comment -->",
      "repository": "elizaos/eliza",
      "createdAt": "2026-01-07T23:58:13Z",
      "mergedAt": "2026-01-12T17:12:53Z",
      "additions": 802,
      "deletions": 890
    },
    {
      "id": "PR_kwDOMT5cIs68vKEB",
      "title": "feat(core): support EMBEDDING_DIMENSION setting to skip API call",
      "author": "0xbbjoker",
      "number": 6357,
      "body": "## Summary\n- Add support for configuring embedding dimension via `EMBEDDING_DIMENSION` character setting, which skips the expensive ~500ms embedding API call during agent initialization\n- Simplify `ensureEmbeddingDimension` method (38 â†’ 27 lines) while maintaining functionality\n- Clean up duplicate mock setup code in runtime tests\n\n## Test plan\n- [x] Added 4 new tests for `ensureEmbeddingDimension`:\n  - Uses numeric EMBEDDING_DIMENSION from settings (skips API call)\n  - Falls back to API call when setting is not provided\n  - Falls back to API call when EMBEDDING_DIMENSION is invalid\n  - Parses string EMBEDDING_DIMENSION values correctly\n- [x] All 51 runtime tests pass\n\nðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)\n\n<!-- CURSOR_SUMMARY -->\n---\n\n> [!NOTE]\n> <sup>[Cursor Bugbot](https://cursor.com/dashboard?tab=bugbot) is generating a summary for commit 36f9a818a8e322086bf13a40934665cc04b6f44d. Configure [here](https://cursor.com/dashboard?tab=bugbot).</sup>\n<!-- /CURSOR_SUMMARY -->\n\n<!-- greptile_comment -->\n\n<h2>Greptile Overview</h2>\n\n### Greptile Summary\n\nThis PR adds support for configuring the embedding dimension via `EMBEDDING_DIMENSION` character setting to skip the ~500ms API call during agent initialization. The implementation simplifies the `ensureEmbeddingDimension` method by checking for a configured dimension first before falling back to the API call.\n\n**Key Changes:**\n- Adds `EMBEDDING_DIMENSION` setting support in `runtime.ts`\n- Refactors `ensureEmbeddingDimension` from 38 to 27 lines\n- Adds 4 comprehensive tests covering various scenarios\n- Removes duplicate mock setup code in tests\n\n**Critical Issue:**\nThe implementation is missing validation to ensure the provided dimension is one of the supported values (384, 512, 768, 1024, 1536, 3072). The database adapter expects these exact values to map to column names (`dim384`, `dim512`, etc.). Invalid dimensions will cause `DIMENSION_MAP[dimension]` to return `undefined`, breaking embedding operations at runtime.\n\n### Confidence Score: 1/5\n\n- Not safe to merge - contains a blocking bug that will break embedding operations with invalid dimension values\n- The P0 issue with unsupported dimension values will cause runtime failures when users configure EMBEDDING_DIMENSION to any value outside the supported set. This breaks the core functionality and must be fixed before merging.\n- packages/core/src/runtime.ts - needs validation for supported dimension values\n\n<h3>Important Files Changed</h3>\n\n\n\nFile Analysis\n\n\n\n| Filename | Score | Overview |\n|----------|-------|----------|\n| packages/core/src/runtime.ts | 2/5 | Added EMBEDDING_DIMENSION config support to skip API call, but missing validation for supported dimension values (384, 512, 768, 1024, 1536, 3072) |\n| packages/core/src/__tests__/runtime.test.ts | 5/5 | Added comprehensive tests for EMBEDDING_DIMENSION feature and cleaned up duplicate mock setup |\n\n</details>\n\n\n\n<h3>Sequence Diagram</h3>\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant AgentRuntime\n    participant Settings\n    participant EmbeddingAPI\n    participant DatabaseAdapter\n    \n    User->>AgentRuntime: initialize()\n    AgentRuntime->>AgentRuntime: ensureEmbeddingDimension()\n    \n    alt EMBEDDING_DIMENSION configured\n        AgentRuntime->>Settings: getSetting('EMBEDDING_DIMENSION')\n        Settings-->>AgentRuntime: dimension value\n        AgentRuntime->>AgentRuntime: Number(dimension)\n        AgentRuntime->>AgentRuntime: validate parsedDimension > 0\n        Note over AgentRuntime: âš ï¸ Missing: validate against [384,512,768,1024,1536,3072]\n        AgentRuntime->>DatabaseAdapter: ensureEmbeddingDimension(parsedDimension)\n        DatabaseAdapter->>DatabaseAdapter: DIMENSION_MAP[dimension]\n        Note over DatabaseAdapter: âš ï¸ Returns undefined for invalid dimensions\n    else No EMBEDDING_DIMENSION configured\n        AgentRuntime->>EmbeddingAPI: useModel(TEXT_EMBEDDING, {text: ''})\n        EmbeddingAPI-->>AgentRuntime: embedding array\n        AgentRuntime->>AgentRuntime: get embedding.length\n        AgentRuntime->>DatabaseAdapter: ensureEmbeddingDimension(length)\n        DatabaseAdapter->>DatabaseAdapter: DIMENSION_MAP[dimension]\n    end\n    \n    DatabaseAdapter-->>AgentRuntime: success\n    AgentRuntime-->>User: initialized\n```\n\n<!-- greptile_other_comments_section -->\n\n<!-- /greptile_comment -->",
      "repository": "elizaos/eliza",
      "createdAt": "2026-01-12T16:16:02Z",
      "mergedAt": "2026-01-12T16:45:56Z",
      "additions": 125,
      "deletions": 34
    }
  ],
  "codeChanges": {
    "additions": 927,
    "deletions": 924,
    "files": 21,
    "commitCount": 25
  },
  "completedItems": [
    {
      "title": "fix: optimize runtime initialization with parallelization and atomic upserts",
      "prNumber": 6342,
      "type": "bugfix",
      "body": "## Summary\r\n\r\nOptimize `runtime.initialize()` performance through atomic upserts and parallelization of independent operations.\r\n\r\n**Results:** Cold start -30%, Warm start -40%\r\n\r\n## Problem\r\n\r\nThe current initialization flow has several in",
      "files": [
        "packages/core/src/__tests__/runtime.test.ts",
        "packages/core/src/runtime.ts",
        "packages/plugin-sql/src/__tests__/integration/base-adapter-methods.test.ts",
        "packages/plugin-sql/src/__tests__/integration/entity-crud.test.ts",
        "packages/plugin-sql/src/__tests__/integration/world.test.ts",
        "packages/plugin-sql/src/base.ts",
        "packages/server/src/services/message.ts",
        "bun.lock",
        "packages/plugin-sql/src/__tests__/integration/memory.test.ts",
        "packages/plugin-sql/src/__tests__/unit/utils.test.ts",
        "packages/plugin-sql/src/neon/adapter.ts",
        "packages/plugin-sql/src/pg/adapter.ts",
        "packages/plugin-sql/src/pglite/adapter.ts",
        "packages/server/src/__tests__/unit/api/agents-runs.test.ts",
        "packages/server/src/api/agents/runs.ts",
        "packages/server/src/api/index.ts",
        "packages/server/src/api/memory/rooms.ts",
        "packages/server/src/api/messaging/jobs.ts",
        "packages/server/src/api/messaging/sessions.ts",
        "packages/server/src/middleware/rate-limit.ts",
        "packages/server/src/middleware/validation.ts"
      ]
    },
    {
      "title": "feat(core): support EMBEDDING_DIMENSION setting to skip API call",
      "prNumber": 6357,
      "type": "feature",
      "body": "## Summary\n- Add support for configuring embedding dimension via `EMBEDDING_DIMENSION` character setting, which skips the expensive ~500ms embedding API call during agent initialization\n- Simplify `ensureEmbeddingDimension` method (38 â†’ 27 ",
      "files": [
        "packages/core/src/__tests__/runtime.test.ts",
        "packages/core/src/runtime.ts"
      ]
    }
  ],
  "topContributors": [
    {
      "username": "greptile-apps",
      "avatarUrl": "https://avatars.githubusercontent.com/in/867647?v=4",
      "totalScore": 63.438,
      "prScore": 0,
      "issueScore": 0,
      "reviewScore": 63,
      "commentScore": 0.43799999999999994,
      "summary": null
    },
    {
      "username": "standujar",
      "avatarUrl": "https://avatars.githubusercontent.com/u/16385918?u=718bdcd1585be8447bdfffb8c11ce249baa7532d&v=4",
      "totalScore": 57.898947636399186,
      "prScore": 15.198947636399186,
      "issueScore": 0,
      "reviewScore": 42.5,
      "commentScore": 0.2,
      "summary": null
    },
    {
      "username": "0xbbjoker",
      "avatarUrl": "https://avatars.githubusercontent.com/u/54844437?u=90fe1762420de6ad493a1c1582f1f70c0d87d8e2&v=4",
      "totalScore": 40.075173815233825,
      "prScore": 40.075173815233825,
      "issueScore": 0,
      "reviewScore": 0,
      "commentScore": 0,
      "summary": null
    },
    {
      "username": "1bcMax",
      "avatarUrl": "https://avatars.githubusercontent.com/u/195689928?u=85f5178dd043e3d408b42cb5685e65806d723b1a&v=4",
      "totalScore": 14.686573590279972,
      "prScore": 14.346573590279972,
      "issueScore": 0,
      "reviewScore": 0,
      "commentScore": 0.33999999999999997,
      "summary": null
    }
  ],
  "newPRs": 1,
  "mergedPRs": 2,
  "newIssues": 0,
  "closedIssues": 1,
  "activeContributors": 7
}