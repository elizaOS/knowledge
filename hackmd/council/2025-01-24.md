# Council Briefing: 2025-01-24

## Monthly Goal

December 2025: Execution excellence—complete token migration with high success rate, launch ElizaOS Cloud, stabilize flagship agents, and build developer trust through reliability and clear documentation.

## Daily Focus

- A surge of rapid shipping (new plugins + bug fixes) is colliding with recurring developer friction (embeddings, plugins, Twitter), making reliability and documentation the decisive trust lever for the Council’s next orders.

## Key Points for Deliberation

### 1. Topic: Reliability vs. Friction in the Developer Onboarding Funnel

**Summary of Topic:** Despite strong momentum (high PR merge rates, faster installs), the community is repeatedly hitting predictable failure modes (vector dimension mismatch, plugin loading quirks, Twitter client oddities) that erode “developer-first” trust unless standardized fixes are productized and documented.

#### Deliberation Items (Questions):

**Question 1:** Do we treat embedding-dimension mismatch as a stop-ship reliability bug (requiring runtime migration/auto-reset), or as a documentation-level workaround?

  **Context:**
  - `Discord 2025-01-23: "Vector dimension mismatch" recurring; fix suggested: "Set USE_OPENAI_EMBEDDING=TRUE in .env" (boja).`
  - `Discord 2025-01-22: workaround suggested: clear local db with `rm -f ./agent/data/db.sqlite` (Yoda26).`

  **Multiple Choice Answers:**
    a) Stop-ship: implement automatic embedding-dimension detection + forced DB migration/segmentation per model.
        *Implication:* Raises immediate engineering cost but converts a top support issue into a silent reliability win, strengthening developer trust.
    b) Hybrid: add guardrails (clear error + one-command reset tool) plus prominent docs; full migration later.
        *Implication:* Reduces support load quickly while keeping roadmap flexibility, but leaves some users exposed to data loss/reset friction.
    c) Docs-only: keep current behavior and publish clearer troubleshooting guidance.
        *Implication:* Fastest path, but risks the perception that ElizaOS is unstable for production and increases Discord support dependency.
    d) Other / More discussion needed / None of the above.

**Question 2:** Should we formalize a “Blessed Runtime Matrix” (Node version, OS/WSL, recommended configs) to reduce install variance, even if it narrows perceived compatibility?

  **Context:**
  - `Discord 2025-01-23: "Users reported success with Node v23.3.0 for resolving various errors."`
  - `Discord 2025-01-22: Windows workarounds frequently involve WSL2 (Vesper).`

  **Multiple Choice Answers:**
    a) Yes—publish an official compatibility matrix and pin recommended versions in tooling/CI.
        *Implication:* Improves reproducibility and reduces support churn, but may frustrate users outside the supported envelope.
    b) Partially—publish recommendations but continue to “best-effort” support broad environments.
        *Implication:* Balances inclusivity with guidance, but may not sufficiently reduce the long tail of setup issues.
    c) No—keep flexibility; invest only in better error messaging and community support.
        *Implication:* Maintains openness but likely keeps onboarding noisy, undermining “execution excellence” optics.
    d) Other / More discussion needed / None of the above.

**Question 3:** Do we prioritize a plugin workflow overhaul (installer/CLI selection + better plugin loading UX) over adding more plugins in the near term?

  **Context:**
  - `Discord 2025-01-23: Request: "Create a CLI installer that selects which adapters/plugins to include" (gel).`
  - `Discord 2025-01-23: Dexscreener plugin workaround: "Remove the API key check in index.ts" (bifkn).`

  **Multiple Choice Answers:**
    a) Yes—freeze new plugins briefly; focus on plugin ergonomics, validation, and docs-first stability.
        *Implication:* Converts ecosystem sprawl into a dependable platform story, but slows perceived feature velocity.
    b) Split-track—continue high-value plugins, but require standardized templates/README + CI checks for acceptance.
        *Implication:* Sustains momentum while improving quality gates, but still risks complexity creep.
    c) No—keep shipping plugins; rely on community troubleshooting and incremental fixes.
        *Implication:* Maximizes breadth quickly, but increases fragmentation and weakens the “reliable framework” brand promise.
    d) Other / More discussion needed / None of the above.

---


### 2. Topic: V2 Trajectory, Backward Compatibility, and Memory Continuity

**Summary of Topic:** Leadership messaging is to “stick to v1” while v2 refactors plugins and memory; however, cross-instance memory continuity is a foundational capability for persistent agents and must be framed as a product contract—not a research note.

#### Deliberation Items (Questions):

**Question 1:** What is our governance stance on v2: a hardening phase with strict compatibility guarantees, or an innovation phase with controlled breakage?

  **Context:**
  - `Discord 2025-01-23: "Jin advised users to 'stick to v1'... v2 will be backwards compatible."`
  - `Discord 2025-01-23: "dev team is refactoring the plugin system and improving memory management" (summary).`

  **Multiple Choice Answers:**
    a) Hardening-first: treat backward compatibility as sacred; limit scope to internal refactors + migration tools.
        *Implication:* Builds long-term trust and reduces ecosystem fragmentation, but may delay high-risk/high-reward architectural shifts.
    b) Dual-track: stable v1 LTS + experimental v2; clear labeling and upgrade path.
        *Implication:* Protects production users while enabling innovation, but requires extra release engineering and documentation discipline.
    c) Innovation-first: allow breaking changes to accelerate capabilities; communicate aggressively and move fast.
        *Implication:* Potentially faster technical gains, but risks developer flight and reputation damage if upgrades become painful.
    d) Other / More discussion needed / None of the above.

**Question 2:** Which memory-continuity primitive should be standardized first to unlock 'persistent, interoperable agents' across clients (Twitter/Discord/Telegram)?

  **Context:**
  - `Discord 2025-01-22: "passing around memories between different agent instances will be important" (jin).`
  - `Discord 2025-01-21: Action item: "Implement memory persistence across different clients" (Jungle).`

  **Multiple Choice Answers:**
    a) Identity unification: canonical user/room identifiers + deterministic memory keys across clients.
        *Implication:* Creates a stable substrate for all higher-order memory features, reducing subtle cross-client inconsistency bugs.
    b) Shared memory bus: a cross-process memory service with explicit read/write APIs and TTL policies.
        *Implication:* Enables multi-agent and multi-instance scaling, but increases operational complexity and surface area.
    c) Policy layer first: standardize what is remembered/forgotten (privacy, retention, consent), then implement tech.
        *Implication:* Improves safety and trust posture early, but may slow the delivery of tangible capability improvements.
    d) Other / More discussion needed / None of the above.

**Question 3:** How aggressively should we productize “one-line model switching” (e.g., DeepSeek via OpenRouter) as a first-class experience rather than a Discord tip?

  **Context:**
  - `Discord 2025-01-23: "openrouter supports it we can change to deepseek in 1 line of code" (jin).`
  - `Discord 2025-01-21: Jin praised DeepSeek R1 as "30x cheaper" and MIT licensed.`

  **Multiple Choice Answers:**
    a) Make it first-class: UI/CLI model picker + validated presets + recommended defaults per use case (JSON/tool-calling).
        *Implication:* Strengthens DX and cost-performance narrative, but requires more QA across providers and model quirks.
    b) Keep it semi-official: document the one-liner and provide a few templates; no UI/CLI changes yet.
        *Implication:* Captures some benefits quickly, but leaves users navigating footguns (JSON reliability, embeddings mismatch).
    c) Defer: focus on core stability; avoid spotlighting provider switching until memory/plugin refactors settle.
        *Implication:* Reduces support scope, but misses a strategic cost advantage and developer excitement lever.
    d) Other / More discussion needed / None of the above.

---


### 3. Topic: Ecosystem Expansion vs. Execution Excellence (Tokenomics, Trust, and Flagship Agents)

**Summary of Topic:** The ecosystem is expanding rapidly (many plugins, integrations, tokenomics proposals), but the Council must prevent strategic dilution by defining a minimal, legible trust-and-utility story that aligns shipping cadence with developer confidence and flagship reliability.

#### Deliberation Items (Questions):

**Question 1:** Do we adopt a simple tokenomics launch model now (bonding/dual-pool), or delay for a stronger trust mechanism (staking/delegation/slashing + TrustDB integration)?

  **Context:**
  - `Discord tokenomics 2025-01-23: debate between "dual pool structure similar to virtuals/pump.fun" (BigChungus) vs "staking/delegation to whitelist trusted agents with slashing" (Vasily Sumanov).`
  - `Discord tokenomics 2025-01-23: "DorianD advocated for simplicity" to reduce adoption barriers.`

  **Multiple Choice Answers:**
    a) Ship simple first: dual-pool/bonding curve with clear fee flows; iterate toward trust later.
        *Implication:* Accelerates time-to-market and clarity, but may entrench weak trust guarantees that are hard to retrofit.
    b) Trust-first: integrate staking/delegation and TrustDB into launch criteria before scaling.
        *Implication:* Aligns with “trust through shipping” and premium positioning, but risks analysis paralysis and delayed momentum.
    c) Two-tier system: simple public launch + optional premium/trusted lane gated by staking/TrustDB signals.
        *Implication:* Creates an adoption on-ramp while preserving a high-trust lane, but adds governance and UX complexity.
    d) Other / More discussion needed / None of the above.

**Question 2:** Should DegenSpartanAI remain maximally transparent (public wallet) or move to a privacy-preserving multi-wallet execution model to protect edge and reduce copy-trading dilution?

  **Context:**
  - `Discord 2025-01-22: public wallet debate; "copy trading diluting the AI's edge" and "considering multiple wallets" (summary).`
  - `Discord 2025-01-23: "DegenSpartanAI temporarily stopped trading because it ran out of SOL."`

  **Multiple Choice Answers:**
    a) Transparency-first: keep a public primary wallet; add operational safeguards (auto-top-up SOL, monitoring dashboards).
        *Implication:* Maximizes community trust and narrative legitimacy, but can reduce trading performance if adversarially copied.
    b) Edge-first: shift to multiple wallets/private execution; publish delayed or aggregated performance reporting.
        *Implication:* Protects strategy alpha, but may weaken transparency-based trust and increase skepticism.
    c) Hybrid: public “proof wallet” running a representative strategy + private execution wallets for main capital.
        *Implication:* Balances trust and performance, but increases operational complexity and must be explained clearly to avoid confusion.
    d) Other / More discussion needed / None of the above.

**Question 3:** Is “Block Tank” best positioned as entertainment marketing, or as an on-chain governance primitive for scalable project vetting and agent trust?

  **Context:**
  - `Discord 2025-01-23: "Block Tank concept... AI-led venture capital/game show" (summary).`
  - `Discord tokenomics 2025-01-23: Jin: "Implement a simple submission fee for Block Tank to reduce spam."`

  **Multiple Choice Answers:**
    a) Marketing-first: treat Block Tank as flagship content to attract builders and partners; keep governance implications light.
        *Implication:* Drives mindshare quickly with lower risk, but may not materially improve ecosystem trust or capital allocation.
    b) Governance-first: formalize scoring, staking signals, and TrustDB outputs as part of launchpad admission.
        *Implication:* Creates a defensible trust layer aligned with mission, but raises design, liability, and manipulation risks.
    c) Phased: start as entertainment + structured data capture; graduate to governance once metrics stabilize.
        *Implication:* Lets the system learn in public with lower stakes, while building the dataset needed for credible governance later.
    d) Other / More discussion needed / None of the above.