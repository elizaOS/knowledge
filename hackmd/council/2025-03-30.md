# Council Briefing: 2025-03-30

## Monthly Goal

December 2025: Execution excellenceâ€”complete token migration with high success rate, launch ElizaOS Cloud, stabilize flagship agents, and build developer trust through reliability and clear documentation.

## Daily Focus

- Stability work advanced (Groq/Telegram fixes and new Twitter triage), but persistent onboarding friction and public tokenomics ambiguity remain the primary threats to developer trust.

## Key Points for Deliberation

### 1. Topic: Runtime Reliability: Plugin Stability (Groq/Telegram/Twitter)

**Summary of Topic:** Core reliability improved via Groq retry hardening and Telegram worldId standardization, while new Twitter memory/interaction issues surfacedâ€”signaling progress in the reliability loop but continued volatility in flagship integrations.

#### Deliberation Items (Questions):

**Question 1:** Should we institute a "flagship plugin stability gate" (Twitter/Discord/Telegram + core DB) that blocks new feature merges until top recurring defects fall below a defined threshold?

  **Context:**
  - `GitHub daily (2025-03-30): "Fixed a critical issue where the Groq plugin would crash instead of retrying" (issue #4087; PR #4118).`
  - `GitHub daily (2025-03-30): "Twitter Plugin Memory Issue: Duplicate memory records created when bot is mentioned" (issue #4115).`

  **Multiple Choice Answers:**
    a) Yesâ€”enforce a stability gate on flagship plugins with explicit SLOs and a bug burn-down requirement.
        *Implication:* Prioritizes execution excellence and reduces churn, but may slow perceived velocity and community novelty.
    b) Partiallyâ€”apply the gate only to release branches and keep main open for feature work with rapid revert capability.
        *Implication:* Balances innovation with stability, but risks unstable main continuing to harm first-time DX.
    c) Noâ€”keep shipping features; handle stability through post-merge triage and incremental fixes.
        *Implication:* Maximizes throughput, but amplifies trust erosion if first-run experiences remain unreliable.
    d) Other / More discussion needed / None of the above.

**Question 2:** What is the Councilâ€™s preferred architectural stance on Twitter memory/interaction semantics: strict deduplication and deterministic threading, or permissive ingestion with downstream cleanup tools?

  **Context:**
  - `GitHub daily (2025-03-30): "Duplicate memory records created when bot is mentioned" (issue #4115).`
  - `Discord ðŸ’»-coders (2025-03-29): "Twitter client was not properly replying to tweets despite checking interactions" (reported by Abderahman).`

  **Multiple Choice Answers:**
    a) Strict mode: deterministic threading + dedup at ingestion, failing closed when uncertain.
        *Implication:* Improves predictability and reduces noisy memories, but may miss interactions under API edge cases.
    b) Hybrid: dedup core cases at ingestion; expose tooling/UI to merge/suppress memories post hoc.
        *Implication:* Keeps agents responsive while giving operators control, but requires additional product surface area.
    c) Permissive: ingest everything; rely on periodic cleanup/compaction jobs and better retrieval filters.
        *Implication:* Simplifies ingestion and avoids dropped data, but increases DB bloat and model confusion risk.
    d) Other / More discussion needed / None of the above.

**Question 3:** Do we prioritize observability next (tracing/instrumentation) over additional bug fixes, to accelerate root-cause isolation across plugins and the core runtime?

  **Context:**
  - `Discord (2025-03-28): "Add tracing capability for LLM interactions similar to LangSmith" (ad0ll).`
  - `GitHub PRs summary (2025-03-29): multiple plugin fixes merged (Twitter/Telegram/Groq) indicating rapid patching but recurring regressions.`

  **Multiple Choice Answers:**
    a) Yesâ€”ship a minimal tracing spine (request IDs, plugin spans, provider timing) across core + flagship plugins.
        *Implication:* Improves incident response and reliability scaling, but consumes engineering time that could close visible bugs.
    b) Sequence: finish current top bugs first, then allocate a dedicated sprint for observability.
        *Implication:* Delivers immediate relief, but may prolong the cycle of recurring issues due to limited telemetry.
    c) Deferâ€”keep observability lightweight and rely on logs/issues until Cloud maturity demands it.
        *Implication:* Preserves short-term velocity, but risks poor MTTR and brittle scaling as usage grows.
    d) Other / More discussion needed / None of the above.

---


### 2. Topic: Developer First: Installation, Versioning, and Onboarding Drift

**Summary of Topic:** The community continues to experience installation failures (Windows, dependency versions, plugin ESM/CJS conflicts) and shifting recommended workflows (npm global â†’ git clone v2-develop + bun), creating a mismatch between docs and reality.

#### Deliberation Items (Questions):

**Question 1:** Should we declare a single "blessed path" for v2 onboarding (tooling + commands + branch), and demote all other paths to advanced/unsupported until parity is restored?

  **Context:**
  - `Discord ðŸ’»-coders (2025-03-29): "Recommended installation method changed from npm global installation to using git clone with the v2-develop branch and bun commands".`
  - `GitHub issues (completed_items): "dependency not found... @elizaos/plugin-sql@^0.25.6" and "quickstart guide instructions inaccurate/outdated".`

  **Multiple Choice Answers:**
    a) Yesâ€”one blessed path (e.g., bun + CLI) with strict version pinning and a single docs entrypoint.
        *Implication:* Reduces confusion and support load, but may alienate users on alternate stacks (npm/pnpm, Windows).
    b) Two pathsâ€”one for contributors (git + bun) and one for builders (npx/cli), each fully supported and tested.
        *Implication:* Serves both audiences, but doubles documentation and CI surface area.
    c) Noâ€”keep flexibility; improve docs to cover multiple valid workflows equally.
        *Implication:* Maximizes openness, but risks ongoing fragmentation and slower trust building.
    d) Other / More discussion needed / None of the above.

**Question 2:** What is the Councilâ€™s stance on Windows-first compatibility: treat it as a first-class requirement now, or as a later hardening phase after core stability?

  **Context:**
  - `GitHub issues (completed_items): "Windows Build Failures: build process fails on Windows due to missing bash command".`
  - `GitHub issue (completed_items): "ElizaOS startup problems on Windows with Node/NVM v23.3" (issue #4191 referenced in contributor log).`

  **Multiple Choice Answers:**
    a) First-class nowâ€”CI must cover Windows and scripts must be cross-platform by default.
        *Implication:* Expands developer reach and reduces friction, but may slow shipping due to platform constraints.
    b) Phasedâ€”ensure Windows works via WSL/containers now; native Windows support becomes a defined milestone.
        *Implication:* Delivers a workable path quickly, but still imposes complexity on a large user segment.
    c) Laterâ€”optimize for Linux/macOS until Cloud provides an abstraction that minimizes local installs.
        *Implication:* Accelerates core progress, but increases near-term drop-off for Windows developers.
    d) Other / More discussion needed / None of the above.

**Question 3:** How aggressively should we standardize plugin packaging (ESM/CJS) to prevent recurring import errors (e.g., EventEmitter) across the ecosystem?

  **Context:**
  - `Discord ðŸ’»-coders (2025-03-29): "Named export 'EventEmitter' not found" for @elizaos/plugin-local-ai; workaround: "npm install eventemitter3" (rchak007).`
  - `Discord (2025-03-28): "Common issues include module resolution errors with packages like @elizaos/plugin-sql and @elizaos/plugin-local-ai".`

  **Multiple Choice Answers:**
    a) Hard standardize: choose one module system (ESM) and enforce via lint/CI across all first-party plugins.
        *Implication:* Reduces class of runtime errors, but may create short-term breaking changes for plugin authors.
    b) Compatibility layer: ship dual builds (ESM+CJS) for first-party plugins and provide templates for community plugins.
        *Implication:* Minimizes breakage and supports broad environments, but increases build complexity and maintenance.
    c) Document-only: keep current packaging; publish clear workarounds and a troubleshooting matrix.
        *Implication:* Fastest short-term, but perpetuates unreliable first impressions and support burden.
    d) Other / More discussion needed / None of the above.

---


### 3. Topic: Narrative Integrity: Auto.fun Ã— ai16z Tokenomics Communication

**Summary of Topic:** Community confusion persists due to conflicting messaging about whether auto.fun has a token and how ai16z accrues value; while clarifications exist (two-pool model, SOL fees buy ai16z), the public single source of truth remains incomplete.

#### Deliberation Items (Questions):

**Question 1:** Should the Council mandate a single canonical tokenomics explainer (diagram + FAQ) and treat all tweets/posts as derivatives that must link back to it?

  **Context:**
  - `Discord ðŸ¥‡-partners (2025-03-29): "Shaw's tweet stating 'auto.fun has no native token' caused confusion"; clarified: fees "auto-buy ai16z" (eskender.eth).`
  - `Discord ðŸ¥‡-partners (2025-03-29): witch described a "two-pool system" (SOL/Agent Token first; fees buy ai16z for secondary pools).`

  **Multiple Choice Answers:**
    a) Yesâ€”publish an immutable canonical explainer and enforce link-backs in all outward communications.
        *Implication:* Reduces narrative drift and improves trust, but adds comms process overhead and slows rapid posting.
    b) Partiallyâ€”publish canonical docs, but allow tweets to stand alone if they are short and unambiguous.
        *Implication:* Balances speed with clarity, but risks repeating the same confusion cycle when phrasing is rushed.
    c) Noâ€”keep comms agile; rely on community correction and follow-up tweets when misunderstandings occur.
        *Implication:* Maximizes spontaneity, but increases reputational risk and perceived inconsistency.
    d) Other / More discussion needed / None of the above.

**Question 2:** What is the Councilâ€™s preferred framing: is ai16z primarily an ecosystem coordination asset, or a direct value-accrual asset tied to launchpad fees (or both)?

  **Context:**
  - `Discord ðŸ¥‡-partners (2025-03-29): "Auto.fun is the launchpad but ai16z is not its native token; fees generated auto-buy ai16z" (iprintmoney / eskender.eth).`
  - `Discord highlights (2025-03-28): community asked for "clarity on AI16Z token utility" and raised concerns about liquidity and mint permissions.`

  **Multiple Choice Answers:**
    a) Coordination-first: governance + ecosystem incentives; fee buybacks are secondary and not guaranteed.
        *Implication:* Sets conservative expectations and reduces regulatory/narrative risk, but may weaken market understanding of utility.
    b) Value-accrual-first: explicitly position fee-driven buy pressure as a core mechanism and key promise.
        *Implication:* Strengthens the economic narrative, but raises expectation-management risk if fees or volumes underperform.
    c) Dual mandate: coordination asset with documented, measurable value-accrual pathways where applicable.
        *Implication:* Most aligned with long-term ecosystem building, but requires disciplined metrics and reporting cadence.
    d) Other / More discussion needed / None of the above.

**Question 3:** Given repeated questions about contract controls (e.g., mint permission), do we prioritize on-chain trust signals now (renounce/remove permissions) or keep admin controls during rapid iteration?

  **Context:**
  - `Discord (2025-03-29): "Remove 'mint' permission on ai16z token" (Kenshiro).`
  - `Discord (2025-03-28): "Requests to renounce the smart contract to remove mint permissions" (Poloethr, Kenshiro).`

  **Multiple Choice Answers:**
    a) Prioritize trust nowâ€”remove/renounce mint permissions and publish verification steps for holders.
        *Implication:* Improves credibility and reduces fear/uncertainty, but can limit future remediation options.
    b) Conditionalâ€”keep controls behind a time-locked, publicly auditable governance process with clear triggers.
        *Implication:* Balances safety with flexibility, but requires governance maturity and careful ops execution.
    c) Deferâ€”retain admin controls until token migration/platform rollout stabilizes, then renounce later.
        *Implication:* Maximizes operational flexibility, but prolongs community concern and narrative fragility.
    d) Other / More discussion needed / None of the above.